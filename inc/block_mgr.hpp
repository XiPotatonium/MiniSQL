#pragma once

#include "lru.hpp"
#include <stdexcept>
#include <stdio.h>
#include <string>
#include <unordered_map>
#include <utility>
#include <stdint.h>

using namespace std;

// ???§³
const int BLOCK_SIZE = 4096;

// ????¦·????????ï…?????¡¤??????????????
struct BlockEntry {
    string file_path;
    int block_index = -1;
    BlockEntry() = default;
    BlockEntry(string file_path, int block_index);
};

namespace std {
    template<>
    struct hash<BlockEntry> {
        size_t operator()(const BlockEntry& entry) const {
            size_t h1 = hash<string>()(entry.file_path);
            size_t h2 = hash<int>()(entry.block_index);
            return  h1 ^ (h2 << 1);
        }
    };

    template<>
    struct equal_to<BlockEntry> {
        bool operator()(const BlockEntry& lhs, const BlockEntry& rhs) const
        {
            return lhs.block_index == rhs.block_index && lhs.file_path == rhs.file_path;
        }
    };
}

struct ActiveBlockInfo {
    int use_count;
    void* addr;
    LRUNodeHandle<BlockEntry> handle;
    bool modified = false;
};

class BlockManager {
    friend class LRUEvictor<BlockEntry>;
private:
    LRU<BlockEntry>* lru;
    unordered_map<BlockEntry, ActiveBlockInfo> active_blocks;
    unordered_map<string, FILE*> active_files;
    FILE* use_file(const string& path);
    void block_writeback(const BlockEntry& entry, void* data);
public:
    BlockManager(int max_blocks = 1024);
    BlockManager(const BlockManager&) = delete;

    // ?????§Õ?????§Ú???????
    ~BlockManager();

    // ?????§Ú??????§Õ?????
    void flush();

    // ?????????????????
    int file_blocks(const string& file_path);

    // ??????¦Â???????ï…????????0
    int file_append_block(const string& file_path);

    void file_delete(const string& file_path);

    // ?????????????????????????????§³?BLOCK_SIZE
    void* use_block(const BlockEntry& entry);

    // ??????????????
    void return_block(const BlockEntry& entry);

    // ???????????????????§Õ?????
    void set_block_modified(const BlockEntry& entry);
};

// ????RAII??????????????BlockGuard????????????????????????????????
class BlockGuard {
private:
    BlockManager* mgr;
    BlockEntry entry;
    void* m_addr = nullptr;
public:
    BlockGuard(BlockManager* mgr, const BlockEntry& entry);
    BlockGuard(BlockManager* mgr, const string& file_path, int block_index);
    BlockGuard(const BlockGuard& guard) = delete;
    BlockGuard(BlockGuard&& guard) noexcept;
    ~BlockGuard();

    // ?????????T??????????????
    template<typename T> T* addr() { return (T*)m_addr; }

    // ?????????T???????????????offset?????????
    template<typename T> T* addr(int offset) { return (T*)((uint8_t*)m_addr + offset); }

    // ???????
    void* addr() { return m_addr; }

    // ????????????
    void set_modified();
};